import sys
import os
import time
import json
import logging
from datetime import datetime
from typing import List, Dict

# Ensure project root is in python path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from app.config import Config
from app.models import Position, MarketData, PortfolioAnalysis
from app.services.market_service import MarketService
from app.services.llm_service import LLMService
from app.services.storage_service import StorageService
from app.services.watchlist_service import WatchlistService

# Configure Logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def main():
    print("ðŸš€ Miguel AI Watchlist Runner - Autonomous Mode")
    
    try:
        Config.validate()
        print(f"ðŸ¤– Model: {Config.MODEL_NAME}")
        llm_service = LLMService()
        watchlist = WatchlistService.load_watchlist() 
    except Exception as e:
        logger.critical(f"Initialization Failed: {e}")
        return

    if not watchlist:
        logger.warning("Watchlist contains 0 items. Exiting.")
        print("âš ï¸ No items in watchlist.json. Please add some!")
        return

    print(f"ðŸ“‹ Loaded {len(watchlist)} items from watchlist.")
    
    updates_made = False
    
    for i, item in enumerate(watchlist):
        ticker = item.get("ticker")
        name = item.get("name", ticker)
        
        # Check if due for run
        # NOTE: For first time testing, you might want to force run by setting last_run to old date
        if not WatchlistService.should_run_analysis(item):
            print(f"â­ï¸  Skipping {ticker} (Last run: {item.get('last_run')}). Next in {(item.get('frequency_days', 30) - (datetime.now() - datetime.strptime(item.get('last_run', '1970-01-01'), '%Y-%m-%d')).days)} days.")
            continue

        print(f"\nðŸ”„ Analyzing due item: {ticker} ({name})")
        
        # Fetch Data
        market_data = MarketService.get_market_data(ticker)
        if not market_data:
            logger.error(f"Failed to fetch market data for {ticker}")
            continue

        # Get Context
        history = StorageService.get_recent_history(ticker)

        # Create dummy position for analysis
        dummy_pos = Position(isin="WATCHLIST", name=name, quantity=0)
        
        try:
            analysis: PortfolioAnalysis = llm_service.analyze_portfolio_position(dummy_pos, market_data)
        except Exception as e:
            logger.error(f"LLM Analysis failed for {ticker}: {e}")
            continue

        # Check for meaningful change
        last_action = item.get("last_action", "N/A")
        new_action = analysis.action
        
        if last_action != new_action:
            print(f"âš ï¸  CHANGE DETECTED: {last_action} -> {new_action}")
        else:
            print(f"âœ… Status unchanged: {new_action}")

        # Save Analysis to File
        report_text = f"**Date:** {datetime.now().strftime('%Y-%m-%d')}\n**Action:** {analysis.action}\n**Reason:** {analysis.long_reason}\n\n*Generated by Miguel AI Watchlist Runner*"
        saved_path = StorageService.save_analysis(ticker, report_text)
        print(f"ðŸ’¾ Report saved to {saved_path}")

        # Update Watchlist State
        item["last_run"] = datetime.now().strftime("%Y-%m-%d")
        item["last_action"] = new_action
        updates_made = True
        
        # Save watchlist immediately after each update to prevent data loss
        WatchlistService.save_watchlist(watchlist)
        print(f"ðŸ’¾ Watchlist updated for {ticker}")

        # Rate Limiting (only if not last item)
        if i < len(watchlist) - 1:
            print(f"â³ Waiting {Config.DELAY_BETWEEN_STOCKS}s...")
            time.sleep(Config.DELAY_BETWEEN_STOCKS)

    if not updates_made:
        print("\nâœ… All items are up to date. No analysis needed today.")
    else:
        print("\nâœ… Batch complete.")

if __name__ == "__main__":
    main()
